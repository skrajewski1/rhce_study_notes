Title: RHCE Exam Notes
Date: 2-27-2025
Author: Sean Krajewski


## Table of Contents 
1. [Note to Reader](#overview)
2. [Resources](#stuff I used to study)
3. RHEL Basics (#a lot of this is RHCSA review)
4. Red Hat System Administration



1. Note to Reader 

These are my personal notes I used for studying for Red Hat Certified Engineer (RHCE) exam (EX294).  
I decided to keep with the running theme of documenting my notes on GitHub.
This isn't meant to be 100% thorough.  RHCE has more advanced networking, security, and introduces automation.
I would say it's a entry point into DevOps concepts in a practical sense.
There is about 20 question on the exam and you need a passing score of 210/300 (70%). No multiple-choice questions!
My experience and those I've talked to that have done the RHCSA to RHCE is to do focus on getting the RHCE as soon as possible.
If you know how to use Ansible you will have a big advantage.  A lot of the RHCE is based on automation via Ansible playbooks.
Again, use my notes if it helps. I'm using Luca Berton's book (see below) as my main study source.



2. Resources

https://www.redhat.com/en/services/certification/rhce
Luca Berton's Mastering the Red Hat Certified Engineer (RHCE) Exam
https://www.youtube.com/watch?v=8Ls56awCJ_U&list=PLYB6dfdhWDePZf4fd4YgGGtSX_vHKv5vz



3. RHEL Basics

lifecycle of RHEL:  full support(5yr), maintenance support (5yr), extended life cycle support (ELS) add-on

Benefits of RHEL:
CPU architectures supported: 86x, ARM, IBM Power, IBM Z, IBM LinuxONE
RHEL includes Ansible automation tech
Red Hat insights provides analytics/remediation  = suppose to maximize uptime and avoid emergencies
Migration tools + RHEL image builder for cloud deployments
live kernel patching, security profiles, trusted software supply chain, automate security processes
performance monitoring/analysis tools
Convert2RHEl tool streamlines the migration process from RPM compatible linux distros like Rocky Linux, AlmaLinux OS, etc
various use cases: edge computing, hybrid cloud deployments, SAP workloads, SQL server hosting, applicaiton development, and high-performance computing (HPC)
Collaborations with cloud providers like GPC, AWS, Azure, Oracle


RHEL installer is called Anaconda  (same for CentOS and Fedora)




### subscription manager

subscription-manager register --username=<name> --password=<pw>

#see available subscriptions
suscription-manager list --available | less

#attach subscription 
subscription-manager attach --auto

#unregister the system
subscription-manager unregister


###shutting down commands

you generally want to limit shutdowns/downtime.  instead try restarting (covered in next section)

#shutdown and restart now 
shutdown -r now

#schedule shutdown at 23:00
shutdown --halt 23:00

#shutdown in 2 minutes
shutdown --halt +2

#shutdown in 2 minutes with a message broadcasted to users logged in
shudown --halt +2 "Urgent. Shudown in TWO minutes."

#cancel shutdown  (this will also be broadcasted to users logged in)
shutdown -c


### Reboot

limitation of systemctl is its inability to do delayed restarts (either now or never)

#restart a service
systemctl restart <service name>

#restart the system (same as effect as shutdown -r now)
systemctl reboot


### Suspending and hibernating

suspension
+ system shuts down (no-power mode)
+ contents of memory are moved to the swap location. on powerup, system reloads from swap
+ boot loader is configured to boot directly to the current kernel

systemctl suspend


hibernation
+ the ystem remains powered on but in a low-power state
+ applications are stopped
+ system state is moved to ram

systemctl hibernate

#combines both
systemctl hybrid-sleep


#Graphical user interface

default gui in RHEL is the GNOME environment.


#Bash scripts 

best used for repetitive or complex tasks (helps reduce human error and improve user experience)

#!/bin/Bash
#Usage: Hello World Bash Shell scripts
#Author: Sean Krajewski
echo "Hello World!"


#Man command

best used in air-gapped environments or exams!

#lists all man pages with descriptions
man -k 


#short description for specific command
man -f <command>

#search all man pages using regulare experessions and open matching ones
man --regex <keyword>

#narrow search to specific section 
man -s <section ID> <keyword>

#searching all man pages for a keyword and out location
man -wK <keyword>



## Red Hat support tool

redhat-support-tool is a utility that provides text based interface for searching inside the knowledge base articles
and filing support cases on the customer portal via command LinuxONE

search option = search between red hat articles
opencase option = open a support cases
addattachment option = attach diagnostic sys info (sosreport)
listcases = list the supported cases of our red hat customer account

# red hat insights

software as service (SaaS) which identifies/remdiates threats, performance, and stability on systems or infrastructures 
running red hat products.
you have to opt-in and requires an agent running.
when a security threat is identified a solution (step-by-step instructions) to remediate the porblem is provided or an ansible playbook
insights is already installed on RedHat +8 systems

to start it use 
you can then audit systems for compliance using the penSCAP policy framework project e.g. auditing for PCI DSS policy


insights-client --register

#users and groups

Linux is a multi-user system. gotta know how to enforce security and access control on users/groups

use su or sudo for switching to users
you may have to use a password for the user 

su mike   (swiches user to mike)

sudo is used for privilege escalation and is only allowed if the user is in a special group i.e. wheel
you can also add the user directly in the file visudo e.g. mike ALL=(ALL) ALL
if you edit the visudo file or add user to the wheel group and run whoami it will show up as them being 'root'

#storage

/ directory is the root. everything falls under it.

/boot  =  files for system bootstrap
/etc   =  config files
/dev   =  files to access hardware
/home  =  home dirs of users (has their personal data)
/root  =  home dir for root
/usr   =  installed software, shared libraries, includes some key files
/usr/bin  = user commands
/usr/sbin = system admin commands
/usr/local = locally customized software
/var   =  dynamically chaning data i.e. log files, cache dirs, databases, printer spooled documents, website contents
/run   =  runtime data for processes started since the lat boot.  includes process id files and lock files (recreated at boot)
/tmp   =  world writable space for temporary files. files not changed in 10 days are auto deleted!!! (/var/tmp is 30 days!!)


#partitioning

crucial part of sys admin
division of hard drives into logical storage units as partitions enables space to be allocated functions to certain areas
e.g. memory swap space
Master Boot Record (MBR) partitioning scheme used since 1982, process of how to partition on BIOS firmware systems (it supported 4 partitions/disk)
GUID partition table (GPT) has succeeded MBR. it offers 128 partitions per disk, larger disk sizes, redundancy with primary/secondary GPTs
GPT is the standard now for Unified Extensible Firmware Interface (UEFI) firmware systems

parted /dev/sda     (launches the GNU parted interactive mode for managing partitions)

example:

[root@localhost ~]# parted /dev/sda
GNU Parted 3.5
Using /dev/sda
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) print
Model: ATA VBOX HARDDISK (scsi)
Disk /dev/sda: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End     Size    Type     File system  Flags
 1      1049kB  1075MB  1074MB  primary  xfs          boot
 2      1075MB  21.5GB  20.4GB  primary               lvm


the print command displays the partition table

you may have used fdisk to partition the hard drive.  fdisk works primarily with MBR and is meant for older or smaller systems.
fdisk is good for simple partitioning
gdisk can be used but you have to install it.  gdisk works better for GPT
parted works better for larger disk >2TB; it's better for modern systems, scripting, automated partitioning

XFS and .ext4 are commonly used for file systems types

#apply a file system to a partition after it's created
mkfs.xfs /dev/sdb1

#manually mounting sda1 to mount point /mnt/data
mount /dev/sda1 /mnt/data

you can also use the UUID (universally unique identifier)


storage devices will be identified by the connection interface via:
/dev/sda  = SCSI
/dev/hda  = IDE 
/dev/nvme0 = NVMe 

#to unmount  (can only do it if its not in use)
umount /mnt/data

#provides a list of resources active for each file system, adding in resolving unmounting challenges
lsof


#Persistent mount
/etc/fstab   (critical for persistent mounting)


best practice is to use UUIDs for devices to vaide potential issues with changing block device identifiers

#reload the systemd after making changes to /etc/fstab
systemctl daemon-reload

#check if there are errors with your /etc/fstab; can also use mount -a and if it fails something is wrong
findmnt --verify

##Installing software

use dnf to install packages.  Yum was and can still be used but dnf is an improved version of yum.
dnf installs not just the software you want but any dependencies that are needed as well.

#list installed packages
dnf list

#search packages matching keywords
dnf search <keyword>

#update all installed packages + kernel updates (essential for maintaining system security)
dnf update

it's a good practice to reboot after updating the kernel


#update only the httpd package
dnf update httpd

#log file of dnf packages installed and removed 
/var/log/dnf.rpm.log

#shows the history of the dnf environments
dnf history

#undo an action from the history just use the ID from from the dnf history list
dnf history <ID>

##web console
web user interface (WUI) introduced via cockpit; it allows admins to connect and manage a system accessing the web interface at a specified address
cockpit service  must be configured to run on the system in order to connect

systemctl status cockpit.socket         (verify status of the service)
systemctl start cockpit                 (starts the cockpit service)
semanage port -a -t websm_port_t -p tcp 9090
firewall-cmd --permanent --service cockpit --add-port=9090/tcp

##SSH network login
ssh user@ipaddress
ssh user@hostname

#using a public key  (key has to have 0600 permission!!)
ssh -i mykey.pem user@ipaddress

#exiting ssh
ctrl + d 

Remote host fingerprint is stored in ~/.ssh/known_hosts
you can generate keys with the following command

ssh-keygen
-t   = type of algo
-b   = number of Bits  
-f   = file name

default configs are RSA 2048 Benefits
For FIPS 186-2 DSA keys must be exactly 1024bits

public key is saved in ~/.ssh/id_rsa.pub 
private key is saved in ~/.ssh/id_rsa         (SHA 256)

#copies pbulic key of the ssh public keyy to the remote system
ssh-copy-id -i .ssh/id_rsa.pub  user@ipaddress

ssh-copy-id command copies the public key and puts it in the ~/.ssh/authorized_keys dir

# you can use ssh-agent to cache the ssh private key in memory at the beginning or during our seesion to have passwordless authentication

eval "$(ssh-agent -s)"        (start the ssh-agent; will output agent pid)
ssh-add ~/.ssh/id_rsa         (add ssh key to agent)
ssh-add -l                    (verify)

## Network Interface and Settings

ip addr     
ip link show

ip link set <interface> up 
ip link set <interface> down

nmcli
nmtui

network configs sotred /etc/sysconfig/network-scripts/ifcfg-<interface>          (make sure to restart service)

Network troubleshooting  
ping 
traceroute 
netstat
ip 

Advanced network features:
bonding
teaming
bridging

## Manage files

cat 
less    (view one page)

#edit files with 
nano
vim
vi      (from Bill Joy cir. 1970s)


vim shortcuts
hjkl          (like cursor movements)
w             (word navigation)
:w            (:w filename will save the file you are working on)   
ZZ            (save files quickly)


4. Red Hat System Administration


## Network Settings

network settings are stored in multiple different files
the network configuration addresses are IPv4, IPv6, or both (called dual stack)


#Hostname
each system is identified by a 'hostname'

commands:
hostname       (shows the host name)
hostnamectl set-hostname <name>       (will set the hostname to whatever you choose)
systemctl restart systemd-hostname    (this is if you changed the config file in /etc/hostname you need to restart the service)


file location:
/etc/hostname
/etc/sysconfig/network     (RHEL 6 and earlier)



#Name Resolution

stub resolver converts the hostname to an ip address and reverses it in the system!

files:
/etc/nsswitch.conf              (determines the 'order' of the lookup; it'll say where the system should check for hostname resolution i.e. /etc/hosts)
/etc/hosts                      (contains static host resolution i.e. local DNS lookup file that maps IP address to hostnames )

commands:
getent hosts google.com        (will test static host resolution)


if getent fails the system trys to contact the DNS defined in the /etc/resolv.conf file

best practice is to mix ipv4 and an ipv6 DNS resolver to gurantee the systems high availability for dual-stack systems


#Network interfaces


Commands:
nmcli con                        (shows all network connections)
nmcli con show --active          (show all active network connections)
nmcli con down <id>              (bring down a connection)
nmcli con up <id>                (bring up connection)
nmcli con mod <id>
nmcli con mod <id> ipv4.dns 192.168.1.254      (modifies the DNS server of <id>)
systemctl restart NetworkManager               (makes the changes take affect for DNS)

 files:
 /etc/sysconfig                           (network configurations)
 /etc/sysconfig/network-scripts/ifcfg-Wired_connection_1    (contains network configuration file; this is deprecated)
 /etc/NetworkManager/system-connections/                    (inside here will be network configuration files; use this on RHEL9+!!!)

remember if you edit the configuration files you nee to reload the connection
nmcli con reload                             (reload after editing config files!!!)


gather network information using:
ip 
ping 
tracepath 
ss

ip link show                                    (identify network interfaces i.e. software/hardware component that allow a device to connect/communicate over a network)
#loopback is a special virtual interface; let's the computer talk to itself and is used for testing/troubleshooting e.g. ping 127.0.0.1 (loopback address)

ip addr
ip a                                            (displays ip addresses)
ip addr show ens3                               (display ip address for ens3)



ip -s link                                      (display performance statistics like received/transmitted packets, errors, drops)


ping -c3 <ip>                                   (checks connectivity of <ip>; sends 3 packets)
ping6 <ip>                                  (similar just works for Ipv6)


ip route                                        (displays routing table)
ip -6 route                                     (display routing table for ipv6)


tracepath                                       (tracing route taken by traffic)


ss                                               (ss replaces netstat command tool and displays socket statistics)
ss -ta                                           (displays all TCP sockets)




##Date and time

timedatectl                               (verify current time settings)
timedateclt list-timezones                (list available time zones)
timedatectl set-timezone Europe/Paris     (set correct time zone)
timedatectl set-ntp true                  (configure ntp synch)
timedatectl set-timezone UTC              (set the timezone UTC)
timedatectl set-time YYYY-MM-DD hh:mm:ss  (set the specific time manually)




chronyd is set to use NTP pool project servers by default

file:
/etc/chrony.conf                           (add the ntp server if you need to pool <ip> iburst)

remember to restart the service after editing chrony.conf

systemctl restart chronyd

chronyc sources -v                         (verify NTP synchronization)

in the past they used NTPd but for now just use chronyd as it's more recent 


#schedule future tasks

automating maintenance tasks ensure system reliability
crond can help solve this with rsync command.
anacron is good for systems not running continously.

files:
/etc/crontab
/etc/cron.d (preferred way)
/etc/cron.hourly
/etc/cron.daily 
/etc/cron.weekly 
/etc/cron.monthly 

a scheduled task is called a cron job

0 */6 * * * /usr/bin/clear_temp_files.sh        (every 6hrs a script cleans temp files out)


you can also use special strings for cron such as

@reboot
@yearly
@monthly
@weekly
@daily
@hourly

for example:
@reboot /path/to/startup_script.sh       (this will run at every system reboot)

there are also system wide cron jobs that you can set in the /etc/crontab file.  here you need to specify a user.

logging cron jobs by default logs are in /var/log/cron
tail -f /var/log/cron      to check if the jobs are running as expected.


Automating a backup (example)

vim /usr/local/bin/backup.sh
#!/bin/Bash
tar -czf /backup/$(date +\%F).tar.gz /important/data
chmod +x /usr/local/bin/backup.sh
crontab -e                                           (create cron job to run daily at 1 AM)
0 1 * * * /usr/local/bin/backup.sh
crontab -l                                           (verify cron job)


Anacron
use for systems not on all the time i.e. hibernating or turned off.


files:
/etc/anacrontab


##systemd timer

systemd timer unit enables timer-based activation of tother systemd units

commands:
dnf install sysstat -y 
systemctl enable --now sysstat


files:
/usr/lib/systmd/system/sysstat-collect

time file collects system statistics every 10 mins for sysstat service


##Manage local users and groups






























